# خطة تنفيذ القراءة التلقائية لرسائل OTP (SMS)

## الهدف
تمكين تعبئة كود OTP تلقائياً في شاشة التحقق داخل التطبيق، مع الحفاظ على الإدخال اليدوي كـ fallback، وبدون طلب صلاحيات قراءة SMS من المستخدم.

## الحالة الحالية (مختصر)
- صيغة رسائل OTP الحالية سليمة للمستخدم لكنها لا تحتوي صيغة Android SMS Retriever الكاملة (`<#>` + App Hash).
- في التطبيق، `AutofillHints.oneTimeCode` موجودة، لكن لا يوجد مستمع فعلي لالتقاط رسالة SMS وتعبئة الخانات تلقائياً.
- صلاحيات SMS (`READ_SMS` و `RECEIVE_SMS`) محذوفة من AndroidManifest، وهذا مناسب لمتطلبات Google Play.

---

## القسم الأول: التطبيق (Flutter App)

### 1) الهدف في التطبيق
- استقبال OTP تلقائياً على Android عبر SMS Retriever (بدون صلاحيات SMS).
- الاستفادة من اقتراح الكود على iOS عبر `one-time code`.
- تعبئة الحقول الستة مباشرة ثم تنفيذ `submit` تلقائياً إن اكتمل الكود.

### 2) الملفات المستهدفة
- `tagadod_app/lib/features/auth/presentation/pages/otp_page.dart`
- `tagadod_app/lib/features/auth/presentation/widgets/otp_input_fields.dart`
- `tagadod_app/pubspec.yaml`

### 3) خطوات التنفيذ
1. إضافة مكتبة مناسبة (موصى بها: `smart_auth`) لدعم SMS Retriever في Android.
2. في `otp_page.dart`:
   - بدء listener عند فتح الصفحة.
   - عند استقبال نص الرسالة: استخراج أول كود من 6 أرقام (`\\d{6}`).
   - تعبئة `_otpControllers` دفعة واحدة.
   - الاعتماد على المنطق الحالي لإرسال OTP تلقائياً عند اكتمال الحقول.
   - إعادة تشغيل listener بعد `إعادة إرسال الرمز`.
   - إيقاف listener في `dispose`.
3. في `otp_input_fields.dart`:
   - الإبقاء على `AutofillHints.oneTimeCode`.
   - تحسين `paste` بحيث لو وصل المستخدم نص كامل فيه 6 أرقام يتم توزيعه على الخانات.
4. عدم إضافة أي صلاحيات SMS إلى `AndroidManifest.xml`.

### 4) قواعد مهمة
- لا تعتمد على WhatsApp/Telegram في autofill (غير متاح قراءتها من التطبيق).
- إذا فشل الالتقاط التلقائي، لا يتأثر التدفق اليدوي.
- منع التكرار: لا يتم إرسال `verify` أكثر من مرة لنفس الكود أثناء حالة loading.

### 5) اختبارات القبول (App)
- Android (جهاز حقيقي):
  - وصول رسالة OTP يؤدي لتعبئة 6 خانات تلقائياً.
  - يعمل نفس السلوك في `register` و `reset`.
  - يعمل بعد الضغط على إعادة الإرسال.
- iOS (جهاز حقيقي):
  - ظهور اقتراح الكود فوق لوحة المفاتيح.
  - تعبئة صحيحة عند الضغط على الاقتراح.
- فشل الالتقاط لا يكسر الإدخال اليدوي.

---

## القسم الثاني: الباك اند (Backend)

### 1) الهدف في الباك اند
تعديل نص رسالة OTP ليكون متوافقاً مع Android SMS Retriever مع الإبقاء على نفس API contract الحالي.

### 2) الملفات المستهدفة
- `backend/src/modules/auth/otp.service.ts`
- `.env` (أو نظام إدارة الإعدادات في البيئة)

### 3) صيغة الرسالة المطلوبة
يجب أن تكون الرسالة في Android بهذا الشكل (مثال):

```text
<#> رمز التحقق في تطبيق تجدد هو: 497769
FA+9qCX9VSu
```

ملاحظات:
- السطر الأول: نص قصير وواضح + كود OTP.
- السطر الثاني: App Hash الحقيقي للتطبيق (11 chars).
- لا تضف أي نص بعد سطر الـ hash.

### 4) خطوات التنفيذ
1. إضافة متغيرات بيئة خاصة بـ App Hash:
   - `ANDROID_SMS_APP_HASH_DEBUG`
   - `ANDROID_SMS_APP_HASH_RELEASE`
2. اختيار الـ hash حسب البيئة (development/release).
3. تحديث بناء الرسالة في `sendOtp` داخل `otp.service.ts`:
   - قالب `register`.
   - قالب `reset`.
4. التأكد أن الرسالة تحتوي **OTP واحد فقط** (6 أرقام).
5. الإبقاء على `devCode` فقط في بيئات التطوير حسب `OTP_DEV_ECHO`.

### 5) توافق مزود الرسائل (SMS Provider)
- التأكد أن مزود SMS لا يضيف توقيعاً أو سطراً إضافياً بعد الـ hash.
- التأكد أن الترميز يدعم العربية إذا لزم، أو اعتماد نص أقصر لتقليل التجزئة.
- التحقق من وصول الرسالة كما هي تماماً على أجهزة Android.

### 6) اختبارات القبول (Backend)
- اختبار وحدة/تكامل لتأكيد أن قالب الرسالة النهائي يطابق الصيغة المطلوبة.
- اختبار فعلي:
  - `POST /auth/send-otp` سياق `register`.
  - `POST /auth/send-otp` سياق `reset`.
  - التأكد أن الرسالة تحتوي `<#>` و App Hash وكود واحد صحيح.

---

## ترتيب التنفيذ المقترح
1. تنفيذ قسم الباك اند أولاً (صيغة الرسالة + env).
2. تنفيذ قسم التطبيق بعده (listener + autofill).
3. اختبار end-to-end على جهاز Android حقيقي.
4. اختبار iOS للاقتراح التلقائي.

## Definition of Done
- Android: OTP يتعبأ تلقائياً من SMS بدون صلاحيات SMS.
- iOS: يظهر اقتراح الكود ويعمل بشكل ثابت.
- لا تغيير سلبي على التدفق اليدوي.
- لا إضافة لصلاحيات SMS في المتجر.
- نفس endpoints الحالية تعمل بدون breaking changes.
